(macro func (name args . body) `(var ,name (lambda ,args (do ,~body))))

(func not (b) (if (= b false) true false))
(func != (lhs rhs) (not (= lhs rhs)))
(func empty? (list) (= list `()))
(func not-empty? (list) (not (empty? list)))

(macro when (cond . forms)
       `(if ,cond
            (do ,~forms)))

(macro cond (. forms)
       (if (not-empty? forms)
           (let ((rest (cdr (cdr forms))))
             (list `if
                   (car forms)
                   (car (cdr forms))
                   (if (not-empty? rest) `(cond ,~rest))))))

(macro switch (value . cases)
       (if (not-empty? cases)
           (let ((case-pair (car cases))
                 (case-value (car case-pair))
                 (case-consequence (cdr case-pair))
                 (rest (cdr cases)))
             (if (= case-value `else)
                 `(do ,~case-consequence)
                 `(if (= ,value ,case-value)
                      (do ,~case-consequence)
                      ,(if (not-empty? rest)
                           `(switch ,value ,~rest)
                           `(error "switch cases exhausted")))))
           (error "no forms passed to `switch` macro")))

(macro loop (cont-name . body) `(let ((,cont-name (lambda () ,~body)))
                                (,cont-name)))

(macro iter (list elem . forms)
       `(let ((-iter-list ,list))
          (loop continue
                (if (not-empty? -iter-list)
                    (do
                     (let ((,elem (car -iter-list)))
                       ,~forms
                       (set -iter-list (cdr -iter-list))
                       (continue)))))))

(macro struct (name . fields)
       (let ((accessors (list))
             (fields-list name))
         (iter fields field
               (set accessors
                    (cons
                     `(func ,(concat-syms name `- field) (,name) (car ,fields-list))
                     accessors))
               (set fields-list `(cdr ,fields-list)))
         `(do
           (func ,(concat-syms `make- name) ,fields (list ,~fields))
           ,~accessors)))

(var input-contents (read-file "./self-host/t.ans"))

(var out-asm-main-proc-name "main")

(var out-asm-prelude (concat ".global " out-asm-main-proc-name "\n"))
(var out-asm-data-section ".section .data\n")
(var out-asm-rodata-section (concat ".section .rodata\n"
                            "print_int_printf_format: .asciz \"%lld\\n\"\n"))

(var out-asm out-asm-prelude)

(macro concat! (var . s)
       `(set ,var (concat ,var ,~s)))

(var out-asm-main-proc-body "")

(macro emit-asm (. asm)
       `(if (is-top-level)
            (concat! out-asm-main-proc-body ,~asm)
            (do
             (let ((proc (current-proc))
                   (asm (concat (proc-body proc) ,~asm)))
               (modify-current-proc (lambda (proc)
                                      (make-proc (proc-name proc)
                                                 asm
                                                 (proc-vars proc))))))))

(var temps-count 0)

(macro inc! (v)
       `(set ,v (+ ,v 1)))

(macro dec! (v)
       `(set ,v (- ,v 1)))

(struct val-desc type loc)

(struct val-loc type value)

(struct function symbol name arity source)

(var builtin-+-source
     (concat
      "\tadd %rsi, %rdi\n"
      "\tmovq %rdi, %rax\n"
      "\tret\n"))

(var builtin-print-int-source
     (concat
      "\tmov %rdi, %rsi\n"
      "\tlea print_int_printf_format(%rip), %rdi\n"
      "\txor %rax, %rax\n"
      "\tcall printf\n"
      "\tmov %rsi, %rax\n"
      "\tret"))

(var builtin-functions
     (list
      (make-function `+ "ananas_builtin_plus" 2 builtin-+-source)
      (make-function `print-int "ananas_builtin_print_int" 1 builtin-print-int-source)))

(macro cons! (car cdr)
       `(set ,cdr (cons ,car ,cdr)))

(var global-variables `())

(iter builtin-functions fn
      (concat! out-asm (function-name fn) ":\n" (function-source fn) "\n")
      (cons!
       (list
        (function-symbol fn)
        (make-val-desc
         `(function ,(function-arity fn))
         (make-val-loc `label (function-name fn))))
       global-variables))

(func emit-const-int (c)
      (make-val-desc `(int) (make-val-loc `imm c)))

(func current-vars ()
      (if (is-top-level)
          global-variables
          (proc-vars (current-proc))))

(func lookup-symbol (name)
      (let ((var-desc false)
            (variables (current-vars)))
        (iter variables var
              (if (and (not var-desc) (= (car var) name))
                  (set var-desc (car (cdr var)))))
        (if (not var-desc)
            (iter global-variables var
                  (if (and (not var-desc) (= (car var) name))
                      (set var-desc (car (cdr var))))))
        (or var-desc (error (concat "failed compilation: unbound symbol " (to-string name))))))

(func len (l)
      (let ((count 0))
        (iter l _
              (inc! count))
        count))

(func compile-form (form)
      (let ((form-type (type form)))
        (switch form-type
                (`int (emit-const-int form))
                (`symbol (lookup-symbol form))
                (`list (compile-list form)))))

(func loc-to-asm (loc)
      (switch (val-loc-type loc)
              (`imm (concat "$" (to-string (val-loc-value loc))))
              (`label (concat (val-loc-value loc) "(%rip)"))
              (`register (val-loc-value loc))
              (`stack (concat "-" (to-string (val-loc-value loc)) "(%rbp)"))
              (else (error (concat "unknown variable location type " (to-string (val-loc-type loc)))))))

(var system-v-call-arg-registers
     (list "%rdi"
           "%rsi"
           "%rdx"
           "%rcx"
           "%r8"
           "%r9"))

(var -1 (- 0 1))

(var procs-list `())
(var procs-ptr-stack (list -1))

(func procs-ptr ()
      (car procs-ptr-stack))

(func is-top-level ()
      (= (procs-ptr) -1))

(func at (l n)
      (let ((list l)
            (count 0))
        (loop continue
              (if (empty? list)
                  (error (concat "index " (to-string n) " out of bounds for a list of length " (to-string (len l)))))
              (if (= count n)
                  (car list)
                  (do
                   (set list (cdr list))
                   (inc! count)
                    (continue))))))

(func current-proc ()
      (at procs-list (procs-ptr)))

(func modify-current-proc (lam)
      (let ((before `())
            (after procs-list)
            (new-proc (lam (current-proc)))
            (counter 0))
        (loop continue
              (if (= (procs-ptr) counter)
                  (do
                   (set after (cons new-proc (cdr after)))
                   (iter before c
                         (cons! c after)))
                  (do
                   (inc! counter)
                   (cons! (car after) before)
                    (set after (cdr after))
                    (continue))))
        (set procs-list after)))

(struct proc name body vars)

(var lambda-counter 0)

(func random-lambda-name ()
      (inc! lambda-counter)
      (concat "lambda" (to-string lambda-counter)))

(func begin-proc (name)
      (cons! 0 procs-ptr-stack)
      (cons! (make-proc name "" `()) procs-list))

(func end-proc ()
      (set procs-ptr-stack (cdr procs-ptr-stack)))

(func proc-stack-size (proc)
      (* (len (proc-vars proc)) 8))

(func allocate-var (type name)
      (let ((loc (if (is-top-level)
                     (error "TODO: support top-level variables")
                     ;; (do
                     ;;  (concat! out-asm-data-section (to-string name) ": .skip 8, 0\n")
                     ;;  (make-val-loc `label (to-string name)))
                     (let ((proc (current-proc))
                           (var-loc (make-val-loc `stack (proc-stack-size proc)))
                           (var-desc (make-val-desc type var-loc)))
                       (modify-current-proc (lambda (proc)
                                              (make-proc (proc-name proc)
                                                         (proc-body proc)
                                                         (cons `(,name ,var-desc) (proc-vars proc)))))
                       var-loc))))
        loc))

(func compile-list (l)
      (when (empty? l)
        (error "failed compilation: cannot compile an empty list"))
      (let ((c (car l))
            (args (cdr l))
            (args-count (len args)))
        (switch c
                (`lambda
                  (if (= (len args) 0)
                      (error "failed compilation: no arguments passed to 'lambda"))
                  (let ((lambda-params (car args))
                        (lambda-body (cdr args))
                        (lambda-name (random-lambda-name)))
                    (if (!= (type lambda-params) `list)
                        (error "failed compilation: lambda parameters should be a list"))
                    (iter lambda-params param
                          (if (!= (type param) `symbol)
                              (error "failed compilation: all lambda params should be of type symbol"))
                          (allocate-var `(box) param))
                    (begin-proc lambda-name)
                    (iter lambda-body form
                          (compile-form form))
                    (end-proc)
                    (make-val-desc `(function ,(len lambda-params))
                                   (make-val-loc `label
                                                 lambda-name))))
                (`var
                 (if (!= (len args) 2)
                     (error (concat "failed compilation: 'var' arguments mismatch: expected 2, got " (to-string (len args)) " instead")))
                 (let ((var-name (car args))
                       (var-value (car (cdr args))))
                   (if (!= (type var-name) `symbol)
                       (error (concat "failed compilation: expected 'var' name to be a symbol, got " (to-string (type)) " instead")))
                   (let ((var-value-desc (compile-form var-value))
                         (var-value-asm (loc-to-asm (val-desc-loc var-value-desc)))
                         (var-loc (allocate-var `(box) var-name))
                         (var-asm (loc-to-asm var-loc)))
                     (emit-asm "\tmovq " var-value-asm ", " var-asm "\n")
                     (make-val-desc `(box) var-loc))))
                (else
                 (let ((function-desc (compile-form c)))
                   (when (not function-desc)
                     (error (concat "failed compilation: unbound symbol '" (to-string c) "'")))
                   (let ((function-type (val-desc-type function-desc)))
                     (when (!= (car function-type) `function)
                       (error "failed compilation: list's car does not evaluate to a function"))
                     (let ((function-arity (car (cdr function-type)))
                           (function-loc (val-desc-loc function-desc)))
                       (when (!= args-count function-arity)
                         (error (concat "failed compilation: expected "
                                        (to-string function-arity)
                                        " arguments, got "
                                        (to-string args-count)
                                        " instead")))
                       (when (!= (val-loc-type function-loc) `label)
                         (error "failed compilation: only function with label location are supported"))
                       (let ((arg-registers system-v-call-arg-registers)
                             (function-label (val-loc-value function-loc)))
                         (iter args arg
                               (let ((arg-desc (compile-form arg))
                                     (arg-loc (val-desc-loc arg-desc))
                                     (arg-val (loc-to-asm arg-loc))
                                     (arg-reg (car arg-registers)))
                                 (emit-asm "\tmovq " arg-val ", " arg-reg "\n"))
                               (set arg-registers (cdr arg-registers)))
                         (emit-asm "\tcall " function-label "\n"))
                       (make-val-desc `(box)
                                      (make-val-loc `register
                                                    "%rax")))))))))

(func gen-start-asm ()
      (concat out-asm-main-proc-name
              ":\n"
              out-asm-main-proc-body
              "\n"
              "\tmovq $60, %rax\n"
              "\tmovq $0, %rdi\n"
              "\tsyscall\n"))

(func gen-procs-asm ()
      (let ((asm ""))
        (iter procs-list proc
              (let ((stack-size (to-string (proc-stack-size proc))))
                (concat! asm
                         (to-string (proc-name proc))
                         ":\n"
                         "\tpush %rbp\n"
                         "\tmov %rsp, %rbp\n"
                         "\tsub $"
                         stack-size
                         ", %rsp\n"
                         (proc-body proc)
                         "\tadd $"
                         stack-size
                         ", %rsp\n"
                         "\tpop %rbp\n"
                         "\tret\n")))
        asm))

(func compile (contents)
      (let ((forms (read contents)))
        (iter forms form
              (compile-form form))
        (concat! out-asm
                 (gen-start-asm)
                 (gen-procs-asm)
                 out-asm-data-section
                 out-asm-rodata-section)))

(compile input-contents)

(print-string out-asm)
