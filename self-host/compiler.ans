;; TODO(oleh): Change the all `function` types to be of form (-> parameter types... return type)

(macro func (name args . body) `(var ,name (lambda ,args (do ,~body))))

(func not (b) (if (= b false) true false))
(func != (lhs rhs) (not (= lhs rhs)))
(func empty? (list) (= list `()))
(func not-empty? (list) (not (empty? list)))

(macro when (cond . forms)
       `(if ,cond
            (do ,~forms)))

(macro cond (. cases)
       (if (not-empty? cases)
           (let ((case-pair (car cases))
                 (case-cond (car case-pair))
                 (case-consequence (cdr case-pair))
                 (rest (cdr cases)))
             (if (= case-cond `else)
                 `(do ,~case-consequence)
                 `(if ,case-cond
                      (do ,~case-consequence)
                      ,(if (not-empty? rest)
                           `(cond ,~rest)
                           `(error "cond cases exhausted")))))
           (error "no forms passed to `cond` macro")))

(macro switch (value . cases)
       (if (not-empty? cases)
           (let ((case-pair (car cases))
                 (case-value (car case-pair))
                 (case-consequence (cdr case-pair))
                 (rest (cdr cases)))
             (if (= case-value `else)
                 `(do ,~case-consequence)
                 `(if (= ,value ,case-value)
                      (do ,~case-consequence)
                      ,(if (not-empty? rest)
                           `(switch ,value ,~rest)
                           `(error "switch cases exhausted")))))
           (error "no forms passed to `switch` macro")))

(macro loop (cont-name . body) `(let ((-should-break false)
                                      (break (lambda () (set -should-break true)))
                                      (,cont-name (lambda ()
                                                    (if (not -should-break) (do ,~body)))))
                                (,cont-name)))

(macro iter (list elem . forms)
       `(let ((-iter-list ,list))
          (loop continue
                (if (not-empty? -iter-list)
                    (do
                     (let ((,elem (car -iter-list)))
                       ,~forms
                       (set -iter-list (cdr -iter-list))
                       (continue)))))))

(macro struct (name . fields)
       (let ((accessors (list))
             (fields-list name))
         (iter fields field
               (set accessors
                    (cons
                     `(func ,(concat-syms name `- field) (,name) (car ,fields-list))
                     accessors))
               (set fields-list `(cdr ,fields-list)))
         `(do
           (func ,(concat-syms `make- name) ,fields (list ,~fields))
           ,~accessors)))

(var input-contents (read-file "./self-host/t.ans"))

(var out-asm-main-proc-name "main")

(var out-asm-prelude (concat ".global " out-asm-main-proc-name "\n"))
(var out-asm-data-section ".section .data\n")
(var out-asm-rodata-section (concat ".section .rodata\n"
                            "print_int_printf_format: .asciz \"%lld\\n\"\n"))

(var out-asm out-asm-prelude)

(macro concat! (var . s)
       `(set ,var (concat ,var ,~s)))

(var out-asm-main-proc-body "")

(macro emit-asm (. asm)
       `(if (is-top-level)
            (concat! out-asm-main-proc-body ,~asm)
            (do
             (let ((proc (current-proc))
                   (asm (concat (proc-body proc) ,~asm)))
               (modify-current-proc (lambda (proc)
                                      (make-proc (proc-name proc)
                                                 asm
                                                 (proc-env proc))))))))

(var temps-count 0)

(macro inc! (v)
       `(set ,v (+ ,v 1)))

(macro dec! (v)
       `(set ,v (- ,v 1)))

(struct val-desc type loc)

(struct val-loc type value)

(struct function symbol name type source)

(var builtin-+-source
     (concat
      "\tadd %rsi, %rdi\n"
      "\tmovq %rdi, %rax\n"
      "\tret\n"))

(var builtin-print-int-source
     (concat
      "\tmov %rdi, %rsi\n"
      "\tlea print_int_printf_format(%rip), %rdi\n"
      "\txor %rax, %rax\n"
      "\tcall printf\n"
      "\tmov %rsi, %rax\n"
      "\tret"))

(var builtin-functions
     (list
      (make-function `+ "ananas_builtin_plus" `(int int int) builtin-+-source)
      (make-function `print-int "ananas_builtin_print_int" `(int int) builtin-print-int-source)))

(macro cons! (car cdr)
       `(set ,cdr (cons ,car ,cdr)))

(var global-variables `())

(iter builtin-functions fn
      (concat! out-asm (function-name fn) ":\n" (function-source fn) "\n")
      (cons!
       (list
        (function-symbol fn)
        (make-val-desc
         `(-> ,~(function-type fn))
         (make-val-loc `label (function-name fn))))
       global-variables))

(func emit-const-int (c)
      (make-val-desc `int (make-val-loc `imm c)))

(func current-vars ()
      (if (is-top-level)
          global-variables
          (env-vars (proc-env (current-proc)))))

(func lookup-symbol (name)
      (let ((var-desc false)
            (variables (current-vars)))
        (iter variables var
              (if (and (not var-desc) (= (car var) name))
                  (set var-desc (car (cdr var)))))
        (if (not var-desc)
            (iter global-variables var
                  (if (and (not var-desc) (= (car var) name))
                      (set var-desc (car (cdr var))))))
        (or var-desc (error (concat "failed compilation: unbound symbol " (to-string name))))))

(func len (l)
      (let ((count 0))
        (iter l _
              (inc! count))
        count))

(func compile-form (form . form-type)
      (let ((t (type form)))
        (switch t
                (`int (emit-const-int form))
                (`symbol (lookup-symbol form))
                (`list (if (empty? form-type)
                         (compile-list form)
                         (compile-list form (car form-type))))
                (else (error "TODO")))))

(func loc-to-asm (loc)
      (switch (val-loc-type loc)
              (`imm (concat "$" (to-string (val-loc-value loc))))
              (`label (concat (val-loc-value loc) "(%rip)"))
              (`register (val-loc-value loc))
              (`stack (concat "-" (to-string (val-loc-value loc)) "(%rbp)"))
              (else (error (concat "unknown variable location type " (to-string (val-loc-type loc)))))))

(var system-v-call-arg-registers
     (list "%rdi"
           "%rsi"
           "%rdx"
           "%rcx"
           "%r8"
           "%r9"))

(var -1 (- 0 1))

(var procs-list `())
(var procs-stack `())

(func is-top-level ()
      (empty? procs-stack))

(func at (l n)
      (let ((list l)
            (count 0))
        (loop continue
              (if (empty? list)
                  (error (concat "index " (to-string n) " out of bounds for a list of length " (to-string (len l)))))
              (if (= count n)
                  (car list)
                  (do
                   (set list (cdr list))
                   (inc! count)
                    (continue))))))

(func current-proc ()
      (car procs-stack))

(func modify-current-proc (lam)
      (let ((new-proc (lam (current-proc))))
        (set procs-stack (cons new-proc (cdr procs-stack)))))

(struct decl name type)
(struct env vars decls)
(struct proc name body env)

(var lambda-counter 0)

(func random-lambda-name ()
      (inc! lambda-counter)
      (concat "lambda" (to-string lambda-counter)))

(func begin-proc (name)
      (cons! (make-proc name "" (make-env `() `())) procs-stack))

(func end-proc ()
      (cons! (current-proc) procs-list)
      (set procs-stack (cdr procs-stack)))

(func proc-stack-size (proc)
      (* (len (env-vars (proc-env proc))) 8))

(func allocate-var (type name . func-loc)
      (let ((loc (if (is-top-level)
                     (error "TODO: support top-level variables")
                     (let ((proc (current-proc))
                           (env (proc-env proc))
                           (var-loc (if (type-is-function type)
                                      ;; TODO(oleh): This is bad if we want to store procedures on the stack.
                                      (car func-loc)
                                      (make-val-loc `stack (+ (proc-stack-size proc) 8))))
                           (var-desc (make-val-desc type var-loc)))
                       (modify-current-proc (lambda (proc)
                                              (make-proc (proc-name proc)
                                                         (proc-body proc)
                                                         (make-env (cons `(,name ,var-desc) (env-vars env))
                                                                   (env-decls env)))))
                       var-loc))))
        loc))

(func lookup-decl (name)
      (if (is-top-level)
          (error "TODO: support top-level decls")
          (let ((found-decl-type false)
                (proc (current-proc))
                (env (proc-env proc))
                (decls (env-decls env)))
            (iter decls decl
                  (when (= (decl-name decl) name)
                    (set found-decl-type (decl-type decl))
                    (break)))
            (or found-decl-type
                (error (concat
                        "failed compilation: did not find a declaration for symbol "
                        (to-string name)
                        " in scope"))))))

(func lookup-proc (name)
      (let ((result false))
        (iter procs-list proc
              (when (= (proc-name proc))
                (set result proc)
                (break)))
        result))

(func reverse (l)
      (let ((result (list)))
        (iter l elem
              (cons! elem result))
        result))

(func types-are-equal (lhs rhs)
      (if (or (= lhs `box) (= rhs `box) (= lhs rhs))
        true
        (cond
          ((and (= (type lhs) `list) (= (type rhs) `list))
           (let ((l lhs)
                 (r rhs)
                 (result true))
             (loop continue
               (cond
                 ((or (empty? l) (empty? r))
                  (break))
               ((not (types-are-equal (car l) (car r)))
                 (set result false))
                 (else
                   (do
                   (set l (cdr l))
                   (set r (cdr r))
                   (continue)))))
             result))
          ((or (= (type lhs) `symbol)
               (= (type rhs) `symbol))
           (= lhs rhs))
          (else (error (concat
                         "TODO: report an error in types-are-equal (lhs = "
                         (to-string lhs)
                         ", rhs = "
                         (to-string rhs)
                         ") |"
                         (to-string (type lhs))
                         ", "
                         (to-string (type rhs))
                         "|"))))))

(func type-is-function (t)
      (and (= (type t) `list)
           (not-empty? t)
           (= (car t) `->)))

(func times (x n)
      (let ((count 0)
            (result (list)))
        (loop continue
          (if (= count n)
            result
            (do
              (inc! count)
              (cons! x result)
              (continue))))))

(func function-type-args (t)
      (reverse (cdr (reverse (cdr t)))))

(func compile-list (l . lam-t)
      (when (empty? l)
        (error "failed compilation: cannot compile an empty list"))
      (let ((c (car l))
            (args (cdr l))
            (args-count (len args)))
        (switch c
                (`decl
                 (if (or (= (len args) 0) (= (len args) 1))
                     (error "failed compilation: not enough arguments passed to 'decl'"))
                 (let ((decl-name (car args))
                       (decl-type (car (cdr args))))
                   (modify-current-proc (lambda (p)
                                          (let ((env (proc-env p)))
                                            (make-proc (proc-name p)
                                                       (proc-body p)
                                                       (make-env (env-vars env)
                                                                 (cons (make-decl decl-name decl-type)
                                                                       (env-decls env)))))))))
                (`lambda
                  (if (= (len args) 0)
                        (error "failed compilation: no arguments passed to 'lambda"))
                  (let ((lambda-type (if (empty? lam-t)
                                       false
                                       (car lam-t)))
                        (lambda-params (car args))
                        (lambda-body (cdr args))
                        (lambda-name (random-lambda-name))
                        (lambda-params-types (if lambda-type
                                               (function-type-args lambda-type)
                                               (times `box (len lambda-params))))
                        (lambda-return-type (if lambda-type (car (reverse lambda-type)) `box))
                        (lambda-arg-registers system-v-call-arg-registers)
                        (lambda-param-idx 0))
                    (if (and lambda-type (!= (len lambda-params-types) (len lambda-params)))
                      (error (concat "failed compilation: lambda expected to have "
                                     (to-string (len lambda-params-types))
                                     " params due to a previous declaration, but has "
                                     (to-string (len lambda-params))
                                     " params instead")))
                    (if (!= (type lambda-params) `list)
                        (error "failed compilation: lambda parameters should be a list"))
                    (begin-proc lambda-name)
                    (iter lambda-params param
                          (if (!= (type param) `symbol)
                              (error "failed compilation: all lambda params should be of type symbol"))
                          (modify-current-proc (lambda (p)
                                                       (let ((env (proc-env p)))
                                                         (make-proc (proc-name p)
                                                                    (proc-body p)
                                                                    (make-env (cons (list param
                                                                                          (make-val-desc (at lambda-params-types lambda-param-idx)
                                                                                                   (make-val-loc `register
                                                                                                                 (car lambda-arg-registers))))
                                                                                    (env-vars env))
                                                                              (env-decls env))))))
                          (inc! lambda-param-idx)
                          (set lambda-arg-registers (cdr lambda-arg-registers)))
                    (iter lambda-body form
                          (set lambda-return-type
                               (val-desc-type (compile-form form))))
                    (end-proc)
                    (make-val-desc (if lambda-type
                                     lambda-type
                                     (list `->
                                           (reverse (cons lambda-return-type
                                                          (reverse lambda-params-types)))))
                                   (make-val-loc `label
                                                 lambda-name))))
                (`var
                 (if (!= (len args) 2)
                     (error (concat "failed compilation: 'var' arguments mismatch: expected 2, got " (to-string (len args)) " instead")))
                 (let ((var-name (car args))
                       (var-value (car (cdr args))))
                   (if (!= (type var-name) `symbol)
                       (error (concat "failed compilation: expected 'var' name to be a symbol, got " (to-string (type var-name)) " instead")))
                   (let ((var-type (lookup-decl var-name))
                         (var-value-desc (compile-form var-value var-type))
                         (var-value-type (val-desc-type var-value-desc)))
                     (if (not (types-are-equal var-type var-value-type))
                         (error (concat "failed compilation: expected variable "
                                        (to-string var-name)
                                        " to have type "
                                        (to-string var-type)
                                        " due to a previous declaration, but the initializer expression "
                                        (to-string var-value)
                                        " has type "
                                        (to-string var-value-type))))
                     (if (type-is-function var-type)
                       (do
                         (allocate-var var-type var-name (val-desc-loc var-value-desc)))
                       (let ((var-value-asm (loc-to-asm (val-desc-loc var-value-desc)))
                             (var-loc (allocate-var var-type var-name))
                             (var-asm (loc-to-asm var-loc)))
                         (emit-asm "\tmovq " var-value-asm ", " var-asm "\n")
                         (make-val-desc var-type var-loc))))))
                (else
                 (let ((function-desc (compile-form c)))
                   (when (not function-desc)
                     (error (concat "failed compilation: unbound symbol '" (to-string c) "'")))
                   (let ((function-type (val-desc-type function-desc)))
                     (when (not (type-is-function function-type))
                       (error "failed compilation: list's car does not evaluate to a function"))
                     (let ((function-param-types (function-type-args function-type))
                           (function-arity (len function-param-types))
                           (function-loc (val-desc-loc function-desc)))
                       (when (!= (val-loc-type function-loc) `label)
                         (error "TODO"))
                       (when (!= args-count function-arity)
                         (error (concat "failed compilation: expected "
                                        (to-string function-arity)
                                        " arguments, got "
                                        (to-string args-count)
                                        " instead")))
                       (let ((arg-registers system-v-call-arg-registers)
                             (function-label (val-loc-value function-loc))
                             (function-param-idx 0))
                         (iter args arg
                               (let ((param-type (at function-param-types function-param-idx))
                                     (arg-desc (compile-form arg))
                                     (arg-loc (val-desc-loc arg-desc))
                                     (arg-val (loc-to-asm arg-loc))
                                     (arg-reg (car arg-registers)))
                                 (if (not (types-are-equal (val-desc-type arg-desc)
                                                           param-type))
                                   (error (concat "compilation failed: expected argument at index "
                                                  (to-string function-param-idx)
                                                  " to have type "
                                                  (to-string param-type)
                                                  ", but it has type "
                                                  (to-string (val-desc-type arg-desc))
                                                  " instead")))
                                 (emit-asm "\tmovq " arg-val ", " arg-reg "\n"))
                               (inc! function-param-idx)
                               (set arg-registers (cdr arg-registers)))
                         (emit-asm "\tcall " function-label "\n"))
                       (make-val-desc `box
                                      (make-val-loc `register
                                                    "%rax")))))))))

(func gen-start-asm ()
      (concat out-asm-main-proc-name
              ":\n"
              out-asm-main-proc-body
              "\n"
              "\tmovq $60, %rax\n"
              "\tmovq $0, %rdi\n"
              "\tsyscall\n"))

(func align-up (x a)
      (+ x (rem (- a (rem x a)) a)))

(func gen-procs-asm ()
      (let ((asm ""))
        (iter procs-list proc
              (let ((stack-size (to-string
                                 (align-up (proc-stack-size proc) 16))))
                (concat! asm
                         (to-string (proc-name proc))
                         ":\n"
                         "\tpush %rbp\n"
                         "\tmov %rsp, %rbp\n"
                         "\tsub $"
                         stack-size
                         ", %rsp\n"
                         (proc-body proc)
                         "\tadd $"
                         stack-size
                         ", %rsp\n"
                         "\tpop %rbp\n"
                         "\tret\n")))
        asm))

(func compile (contents)
      (let ((forms (read contents)))
        (iter forms form
              (compile-form form))
        (concat! out-asm
                 (gen-start-asm)
                 (gen-procs-asm)
                 out-asm-data-section
                 out-asm-rodata-section)))

(compile input-contents)

(print-string out-asm)
